# Program  
- **Server**  
- **Client**  

## Modules  
- **list**:  
  - Stores session and dialog objects.  

- **buffer**:  
  - Manages text data, including searching and manipulating strings.
  -   

- **dialog**:  
  - Represents a simple object containing a sentence and its state.  
  - Example: A "welcome state" might include `state: "welcome_state"` 
    and `sentence: "Hello dear client"`.
  - All dialog objects are stored in a list.  

- **session**:  
  - Stores client connection data, tracks the current dialog state, 
    and keeps client responses to server questions.  

## Server  
- Starts a local socket and listens for incoming connections.  
- Accepts connections and initializes a new session for each client.  
- All streams operate in **non-blocking mode**.  
- Uses `pselect` to wait for client readiness (read/write operations).  
- Handles signals, ensuring proper session cleanup before shutdown:  
  - `SIGUSR1` - Reloads configuration (reloads dialogs from a file).  
  - `SIGINT` - Stops the server.  
- Removes inactive connections.  
- Properly handles connection shutdowns.  

## Client  
- Connects to the server.  
- Waits for the server to send information.  
- Responds to questions and sends answers to the server.  
- Properly handles connection shutdowns.  

## Base  
- Contains reusable functionality, such as reading/writing from file descriptors.  

### Limitations
- The maximum length of a single input line is **128 characters** (including the newline character).
- Input exceeding this limit may be truncated or cause undefined behavior.
- Clients should ensure that their responses do not exceed this limit.
- The program uses 'dirty' strings that end with '\n'. If a valid C string is needed, it can be converted.




Размышления касательно сессии. Смотри у меня на данный момент есть сесссия у которой есть состояние диалога и статус диалога, то есть состояние в состоянии. Для этого понадобилось ввести 2 функции одна из которых проверяет можно ли изменить статус диалога, а другая состояние диалога. Состояние сессии по большей степени можно сказать является переключателем хотя сейчас и представленно как перечисление. В общем как понятно из ситуации не очень удобно управляться со всей этой штукой. Нужно проверять сперва одно потом второе. Но и вынести это как то отдельно не представляется возможным так как оно завязано на чтение и записи данных. Пример если буфер пустой, то мы можем сметить статус диалога и перейти в режим получения данных от пользователя, если мы находимся в состоянии получения данных и получили строку со стороны пользователя, то в таком случае мы можем выполнить переход на следующее состояние, а статус должне быть установлен как готов к отправки данных. В общем одно с другим связанно. Проблема с неймингом, вся эта канитель вместе обрабатывается функцией серверной части которую я обозвал как try_change_state_session, не особо меня устраивает. Нужно чет более выразительное. 
похоже я нашел выход. Дело в том что dialog_state_t смотриться вполне логично, но есть еще одно перечисление которое отражает как бы статус самого диалога: dialog_status_t. И чет мне кажется что это и близко не относится к статусу диалога, возможно это второе перечисление которое выступает в качестве переключателя стоит обозвать как session_state с полями: ready_send_info, ready_receive_info. Тогда таким образом я получаю возможность спервая вызвать условно try_change_session_state если конечно это возможно, а если нет то проверяю можно ли выполнить смену текущего состояния диалога try_change_dialog_state_session. Хотя признаться этот вариант меня также не привлекает



















нужно сформировать требование к серверу, и клиенту.

Во первых сервер должен состоять из нескольких компонентов(модулей)
    с которыми он будет взаимодействовать:
        Первым из модулей это должна быть структура данных
            которая будет хранить данные о текущей сессии если конкретно
            то она должна виглядеть следующим образом:
            typedef struct 
            {
                int sd;/*socket descriptor*/
                
                dialog_state_t state;/*which state the client is currently*/
                status_state_t status_state;

                buffer_t read_buffer;
                buffer_t write_buffer;
            } session_t;
            dialog_state_t это перечисление задача которого отображать в 
            каком состоянии находится клиент. Находится в четвертом модуле.
            Пример:
            typedef enum
            {
                hello_state,
                ask_state,
                ask2_state,
                exit_state,

                kill_state,

            } dialog_state_t;
            помимо этого перечисления потребуются вспомогательные функции
            основная задача которых это управлять сессией(структурой), как 
            пример: это должны быть функции для работы с буфферами данных, 
            где на них в основном будет ложится задача внести модификации
            в текущий буфер и обновить его размерность, ситуации когда это
            нужно будет использовать: читаем/пишем данные из/в сокета, если
            читаем то нужно дописывать в буфер с определенного места, тут
            просто достаточно передать указатель со смещением 
            (read_buff + size_read_buff), когда пишем то в этом случае нужно
            убрать из буфера n записанных символов в сокет.
            Помимо этого нужно еще каким-то образом различать некоторые 
            критические ситуации. Планируется что сервер всегда будет 
            обращаться первым, а клиент должен будет отвечать серверу.
            Проблема состоит в определении какое именно действие должно быть
            выполненно, для решение этого можно ввести дополнительное 
            перечисление которое будет отвечать за состояние в состоянии, 
            пример:
            typedef enum
            {
                nothing_yet_do,/*just entered in current state*/
                ready_send_info,
                ready_receive_info,

                ready_change_state,

            } status_state_t;
            тогда в таком случае инициализация новой сессии разговора будет
            иметь условно dialog_state_t hello_state, а status_state_t 
            nothing_yet_do, и исходя из этого можно понять что мы находимся
            в начале нашего диалога и еще ничего не сделали, и чтобы поставить
            сокет на прослушку готовности, нужно перейти в состояние когда у 
            нас есть информация для отправки ready_send_info. Можно
            опустить nothing_yet_do и сразу же запихнуть в буфер информацию
            чтобы как можно скорее поставить сокет на прослушку, а состояние
            перевести в ready_send_info. После того как write_buff станет
            пуст другими словами когда мы всю информацию смогли отправить 
            клиенту, мы можем попытаться получать информацию для чтения ответ
            клиента, конец ответа пользователя должен стать перевод строки '\n'.
            Таким образом мы будем ставить по очередно сокет сперва на готовность
            к записи потом на готовность к чтению. На стороне клиента было бы 
            неплохо запретить пользователю вооще что либо передавать серверу 
            до тех пор пока не получим от сервера перевод строки, поняв тем 
            самым что сервер перестал задавать вопрос.
            После получения ответа от клиента, мы должны перейти в следующее
            состояние dialog_state_t и запихнуть в буфер write_buff информацию
            а также сменить состояние на ready_send_info, и поставить сокет 
            на прослушку.

        Второй модуль должен представлять из себя структуру данных которая 
            позволит нам хранить данные сессий. Особо важно грамотно продумать
            удаление закрытых сессий. Возможно стоить ввести дополнительное
            состояние kill_state которое будет обрабатываться отдельно после
            обработки событий, но перед очередной выборкой событий, на этом
            этапе я смогу безболезненно удалить завершившуюся сессию, закрыв 
            все дескриптора, "и в данной ситуации нужна структура которая 
            позволит одновременно проходить по ней и при этом удалять из 
            себя элементы", да такая структура нужна была бы но я могу 
            поступить проще, в список можно добавить поле которое будет 
            остлеживать общее количество сессий, позже я выделяю масив int 
            в которые будут писаться ключевые поля из сессий, а именно номера
            файловых дескрипторов, а все остальное должно быть проставленно в -1,
            и после просто перебираем этот масив и отдаем списку на удаление 
            номера файловых дескрипторов. После начинается снова выборка событий.
            Подробности по второму модулю смотреть в файле readme_additional.

        Третий модуль возможно стоит вынести в третий модуль логику обработки
            буферов, и структуру которая будет представлять эти же буферы. 
            Хотя в таком случае скорей всего потребуются обёртки которые 
            будут делегировать вызов скорей всего с первого модуля в третий.
            В принципе на данном этапе планирования мне нравится идея вынесения
            буферов в третий модуль, ведь открывается чудесная возможность 
            играться с буфером как я того пожелаю. Например: структуру буфера
            я могу сделать разнообразной, не объязательно хранить только сам 
            масив и его размерность, я могу добавить поле которое будет отвечать
            за количество прочитанных или же записанных данных из/в буффер, во
            время системных вызовов read и write, а потом условно суммировать 
            эти значения и просто выполняя сдвиг и возвращая указатель на позицию
            с которой можно продолжить чтение или запись данных. Возможно во время
            написания программы я найду еще какие-то возможности.
            typedef struct
            {
                char buffer[BUFFER_SIZE];
                int length;

                int offset;
            } buffer_t;
            В модуль буфера было бы весьма кстати вынести логику чтения и записи
            где в качестве из и куда писать передавался файловый дескриптор, а 
            сами операции чтения и записи выполнялись уже внутри этого модуля. 
            Также считаю что сюда нужно добавить логику которая позволяла бы получить
            строку из данного буфера как пример буфер выполнил чтение у него внутри
            хранится информация, и теперь нужно разбить эту информацию по строкам
            в качестве разделителя можно передавать просто символ, а на выходе
            получать указатель на строку, и в качестве возвращаемого параметре
            длину этой строки.

        Четвертый модуль, будет представлять из себя структуру типа:
            typedef struct
            {
                dialog_state_t state;/*key*/
                char* write_msg;
                dialog_t* next;
            } dialog_t;
            В четвертый модуль планирую вынести функцию которая соберет нам 
            список, в правильном порядке: условно сперва приветствование, вопрос1,
            вопрос2, прощание, и возможно понадобится еще одна пустая для 
            состояния kill_state. Также я предполагаю сюда же винести 
            вспомогательную функцую которая будет копировать write_msg в 
            write_buff, а возможно вынесу в третий модуль. Пока что точно 
            не знаю.


        Главная программа сервер. В основном она должна просто поднимать
            сокет на прослушивания входящих запросов на соединение, обрабатывать
            диалог между клиентом и сервером. При этом все общение должно 
            происходить в не блокирующим режиме, то есть данные будут 
            обрабатываться порционно. И для этого должен быть задействован
            системный вызов select. На стороне сервера все просто, подняли
            привязали его к файлику, поставили прослушивать. Сформировали
            fd_set-ы(сделали выборку событий), обработали события, удалили
            лишнии сессии, которые уже подошли к концу. Это общий принцып 
            работы сервера.
            Для того чтобы сделать сервер хоть сколько-то управляемым,
            использоваться будет системный вызов pselect который умеет
            обрабатывать сигналы. После получения сигнала сервер должен
            закрывать все возможные соединения выполнить действия которые
            были ему приказаны через сигналы, а после снова запускать 
            сервер, при условии что полученный приказ не соответствует
            полной остановке сервера.

            Ну а теперь от общего к частному: нужно понять на каком этапе,
            и каким образом производить скажем так обновление текущего состояния
            сессии каждого клиента. С логической точки зрения это однозначно 
            должна быть обработка событий, но нужно конкретизыровать, 
            прикинуть как лучше этот процесс организовать и впишется ли он
            в этот скажем так слой. Итак принцип работы прост, сперва нужно 
            обработать уникальную ситуацию а именно проверить нет ли в fd_set-е
            номера дескриптора сокета сервера который слушает нет ли запроса
            на подключение, если информация на слушащий дескриптор поступила
            необходимо обработать, эту уникальную ситуацию и попытаться 
            подключить нового клиента, попутно при этом сформировав для нового
            клиента сессию, и подготовив ему пачку данных для отправки к 
            клиенту, дальше используя функции из второго модуля, который содержит 
            код списка, проходимся по списку и вытаскиваем поля sd(номер 
            дескриптора сокета), проверяем в каком именно fd_set-е содержится 
            наш текущий дескриптор, если он отсутствует в обоих fd_set-ах, 
            игнорируем его, в противном случае, отдаем его в специальный 
            обработчики либо для чтения либо для записи в зависимости от текущего 
            состояния. Где произойдет чтение либо запись, по хорошему следующим
            этапом должна стать проверка состояния сессии, то есть мы выполнили
            запланированые действия и выполняем проверку, если условно действие 
            до конца не было выполненно ввиду того что наши буферы сессий не 
            пусты, то в такой ситуации мы не должны менять текущее состояние
            сессии, а также статус он тоже должен остаться не изменным это тип
            status_state_t внутри сессии. В противном случае если у нас внутреные
            буфферы пусты, нам необходимо как минимум сменить статус текущего 
            состояния, а как максимум и само состояние. Порядок действий должен
            быть следующим: по умолчанию после инициализации статус состояния 
            установлен в ready_send_info, из этого статуса мы можем перейти 
            в следующий статус ready_receive_info, а дальше попадая в 
            обработчик состояния, мы возможно будем производить манипуляции с 
            буферами если они потребуются, хотя я в этом как-то сомневаюсь, 
            возможно разве что очищать(занулять) буфер для чтения, из статуса
            состояния ready_receive_info переход происходит в статус 
            ready_change_state, на этом этапе мы должны перейти к следующей
            функции обработчика, и она должна сменить нам текущее состояние
            сессии, а также статус состояния на ready_send_info, и поместить в 
            буфер информацию которая должна быть отправленна. На этом обработку
            события можно завершить для текущей сессии. После того как обработка
            события была завершенна для всех, сессий, идет переход к следующему
            этапу, а именно закритию лишних сессий, те у которых состояние 
            установлено в kill_state. После повторяется процесс выборки события,
            обработка события, закритие сессий.

            Обработка уникального события когда клиент стучится на слушающий сокет
            чтобы установить соединение, должно иметь свой уникальный обработчик
            ведь нам же нужно подготовить новый открытий сокет, и в основном 
            сводится к тому что мы формируем новую сессию, в качестве состояния
            ставим самое первое, а статус нужно установить в ready_send_info, ну 
            и поместить информацию в буфер. И наконец саму сессию поместить в 
            список и на этом все. Ошибок здесь не будет ведь для того чтобы 
            конкретная сессия начала обрабатываться в fd_set-е должен находится, 
            номер файлового дескриптора созданной сессии, а он не может туда
            попасть так как этой сессии не существовало на момент выборки события.

            Уточнение. Во время удаления уже завершенных сессий, задача сервера
            будет заключаться в закритии сокета для чтения и записи при помощи
            системного вызова shutdown(sd, SHUT_RDWR), а после следует
            системный вызов close, и удаление сессии.

        Принцип общения между сервером и клиентом. Общение должно происходить по
            очереди клиент стучится на сервер. И сервер первым начинаем общение
            после того как соединение установленно. В этот момент клиент ожидает
            пока сервер выговорится, после этого начинает говорить клиент, после
            нажатия клавиши Enter клиент заканчивает говорить. Сервер также 
            заканчивает свой разговор при помощи '\n'.


        Клиентское приложение. Приложение скорей всего будет просто зациклено, и
            крутиться по кругу пока клиент не словит ситуацию конца файла. В моем
            представлении для этого нам потребуется перевести сокет в 
            неблокирующий режим работы, также я считаю что было бы неплохо 
            в неблокирующий режим работы перевести и стандартный ввод/вывод.
            Также можно было бы написать небольшой вспомогательный модуль с двумя
            буферами, в первом хранится полученная информация с сервера, во втором
            то что мы получили со стороны клиента через стандартный ввод. Сперва
            клиент ожидает получение всех данных со стороны сервера, ознакой 
            прекращения вещания со стороны сервера станет перевод строки '\n', 
            как только мы нашли получили всю строку от сервера, серверная сторона
            переходит в готовность получения данных от клиента. Потом клиент 
            набирает ответ для сервера и передает его серверу. ОПИСАННО 
            ПОВЕРХНОСТНО.

        Первый модуль для клиентского приложения. Для выполнения этой задачи 
            потребуются вспомогательные модули. Для начала нужно определить чем
            конкретно занят клиент в текущий момент. Вводим перечисление:
            typedef enum
            {
                ready_receive_info,
                print_received_info,
                enter_sending_info,
                ready_send_info,
            } client_state_t;
            Клиент может перебывать только в одном состояния в конкретный момент
            времени. С запуском приложения клиент находится в состоянии 
            ready_receive_info, и сокет ставиться на прослушку для получения 
            данных от сервера. Другими словами делаем выборку события, и ожидаем.
            После начинаем обработку событий. Читаем с сокета столько сколько
            можем, если при этом обнаружили что прочитали весь запрос со стороны
            сервера, нужно произвести смену текущего состояния клиента с 
            ready_receive_info на print_received_info, и ставим на прослушку
            стандартный вывод. Когда поток готов принять данные, пихаем в него 
            полученный запрос со стороны сервера(клиенту нужно знать что хочет
            от него сервер). Если весь буфер был опустошен, нужно снова сменить
            состояние, с print_received_info на enter_sending_info, и на прослушку
            ставим стандартный ввод, до тех пор пока не наступит конец строки, а
            возможно клиент захочет прервать общение с сервером в таком случае
            нужно закрыть через shutdown сокет на чтение и запись и просто выйти
            из программы. Если в буфер попал перевод строки значит ответ для 
            сервера готов. И состояние снова переводим с enter_sending_info
            на ready_send_info, сокет на прослушку, когда готов отправляем данные.
            После опустошение внутреннего буфера, снова переход в новое состояние.
            Меняем ready_send_info на ready_receive_info. Для состояния 
            ready_receive_info имеется также уникальная ситуация, например select 
            может сказать что нам что-то пришло, но при попытке чтения вызов read 
            вернет 0 это означает что сервер прекратил с нами общаться, и закрыл 
            сокет.


        Что ж теперь я понял как я могу это использовать. Я написал сервер который
            уже умеет использовать системный вызов select, но хочу его 
            доработать(не нужно код мне кидать, это моя задача, мне нужно оценка 
            насколько это будет грамотное решение) при помощи того же pselect, где 
            я планирую использовать два сигнала условно sigint будет приводить к 
            тому чтобы программа обновила структуру диалога загрузив конкретный файл 
            с диска, а другой сигнал с ним нужна помощь по тому как не могу придумать
            какой использовать и как его передавать(но важно чтобы он был безвреден 
            не положил принудительно процесс, и не влиял косвенно на него как 
            sigstop или sigcont, что то безвредное и чтобы также использовалась 
            клавиатурная комбинация какая-то жду твои предложения), его задача 
            положить демон сервер. Только оба сигнала должны обрабатываться 
            корректно и грамотно. 
        В моем представление это должно выглядеть как-то так: будет переменная:
            volative sig_atomic_t server_state; 
            
            будут 3 define со значениями: 
            NOTHING_DO, RELOAD_CONFIG, STOP_SERVER, 

            задача обработчика только обработать сигналы, по хорошему нужно блокировать 
            возможность простой смены из состояния RELOAD_CONFIG в STOP_SERVER или 
            наоборот, считаю что правильным будет после обработки состояния 
            RELOAD_CONFIG возвращение сервера в состояние NOTHING_DO, ну а из 
            состояния STOP_SERVER перейти в другие вообще не должно представляться 
            возможным. Задача обработчика сигнала будет состоять только в смене 
            значения server_state, так как обработчик сигнала будет обрабатываться 
            сразу же после выхода из pselect, а только потом начнет выполнение 
            остальной код, то я смогу просто поставить проверки по типу 
            if (server_state == STOP_SERVER) и ее похожие. Где уже эти проверки и 
            начнут работу, с моей точки зрения обработка должна выглядеть следующим 
            образом: все открытые сокеты должны "упасть" и оповестить клиентов, 
            системный вызов shutdown (ложить нужно и на чтение и на запись). Вопрос 
            который меня интересует нужно ли ждать пока я смогу написать или же я 
            могу их положить сразу не дожидаясь пока появится возможность в них 
            писать? Что касается слушающего сокета то он должен также упасть и 
            используя unlink убрать файл, конечно же удалить все fd из таблицы 
            файловых дескрипторов, и уже после этого в зависимости от состояния 
            сервера ли просто exit(EXIT_SUCCESS) либо перечитать файл конфигурации, 
            и снова на прослушку и обработку клиентов. 



















еще немного размышлений в направлении того куда лучше вынести функциональность. 
У меня есть модули buffer, session, custom_io. И вот модуль сессии использует 
внутри себя модуль буффера, для временного хранения и управления текстовыми данными. 
И сейчас я думаю как поступить, сам по себе модуль сессии отражает конкретного 
клиента, и его состояние, но в тоже время эта сессия должна писать и читать 
данные собственно в буфер, можно добавить еще один уровень(прослойку) которая 
будет внутри себя вызывать функции из модуля custom_io но вот как по мне вносить 
в сессию такого рода функциональность это как то излишнее. Но тогда мне нужен 
другой подход который позволит это решить. Из вариантов сделать простой гетер 
который будет возвращать буффер из сессии, а уже с этим буферром я буду 
непосредственно и работать передавая его тому же модулю custom_io или просить 
выполнить с ним другую логику. Но эта особенность будет связана только с 
операциями чтения и записи. Например если мне понадобиться выполнить функцию 
которая позволит нам узнать возможно ли сменить состояние сессии на следующее, 
или же функция собственно сменны состояния сессии должна работать с сущностью 
сессии как в целом. То есть тонкость связана с той особеностью что в некоторых 
ситуациях мне нужно работать с сессией не как с полноценой сущностью в виде 
сессии, а с отдельной  сущностью конкретно с буффером, которая является 
составляющей частью сессии. 
Пойдем дальше почему меня это так беспокоит, дело в том что завязка идет на 
тех самых операциях чтения и записи, которые могут вызвать некоторые моменты: 
например в буфере закончились данные, значится нужно сменить состояние, и быть 
готовым получать данные от пользователя, или же если в буфере нашолся сепаратор 
строки, который выступает ознакой того что клиент уже ответил на запрос сервера. 
В обоих ситуациях нужно менять состояние сессии, для сменны нужно работать со 
списком, который хранит данные диалога, но логику поиска следующего диалога не 
возможно вынести в логику списка так как это не его ответственность, по этой 
причине остается отнести логику выбора следующего диалога отнести к серверу, 
то есть сервер будет тем самым менеджером который будет работать со всеми 
сессиями, сперва вызывая операцию чтения записи, после выполнять проверку 
готова ли сессия сменить свое состояние, если да выполняется смена состояния 
при помощи серверной части. Похоже я уже нашел ответ на проблемный момент.




