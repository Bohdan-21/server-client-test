нужно сформировать требование к серверу, и клиенту.

Во первых сервер должен состоять из нескольких компонентов(модулей)
    с которыми он будет взаимодействовать:
        Первым из модулей это должна быть структура данных
            которая будет хранить данные о текущей сессии если конкретно
            то она должна виглядеть следующим образом:
            typedef struct 
            {
                int sd;/*socket descriptor*/
                
                dialog_state_t state;/*which state the client is currently*/
                status_state_t status_state;

                buffer_t read_buffer;
                buffer_t write_buffer;
            } session_t;
            dialog_state_t это перечисление задача которого отображать в 
            каком состоянии находится клиент. Находится в четвертом модуле.
            Пример:
            typedef enum
            {
                hello_state,
                ask_state,
                ask2_state,
                exit_state,

                kill_state,

            } dialog_state_t;
            помимо этого перечисления потребуются вспомогательные функции
            основная задача которых это управлять сессией(структурой), как 
            пример: это должны быть функции для работы с буфферами данных, 
            где на них в основном будет ложится задача внести модификации
            в текущий буфер и обновить его размерность, ситуации когда это
            нужно будет использовать: читаем/пишем данные из/в сокета, если
            читаем то нужно дописывать в буфер с определенного места, тут
            просто достаточно передать указатель со смещением 
            (read_buff + size_read_buff), когда пишем то в этом случае нужно
            убрать из буфера n записанных символов в сокет.
            Помимо этого нужно еще каким-то образом различать некоторые 
            критические ситуации. Планируется что сервер всегда будет 
            обращаться первым, а клиент должен будет отвечать серверу.
            Проблема состоит в определении какое именно действие должно быть
            выполненно, для решение этого можно ввести дополнительное 
            перечисление которое будет отвечать за состояние в состоянии, 
            пример:
            typedef enum
            {
                nothing_yet_do,/*just entered in current state*/
                ready_send_info,
                ready_receive_info,

                ready_change_state,

            } status_state_t;
            тогда в таком случае инициализация новой сессии разговора будет
            иметь условно dialog_state_t hello_state, а status_state_t 
            nothing_yet_do, и исходя из этого можно понять что мы находимся
            в начале нашего диалога и еще ничего не сделали, и чтобы поставить
            сокет на прослушку готовности, нужно перейти в состояние когда у 
            нас есть информация для отправки ready_send_info. Можно
            опустить nothing_yet_do и сразу же запихнуть в буфер информацию
            чтобы как можно скорее поставить сокет на прослушку, а состояние
            перевести в ready_send_info. После того как write_buff станет
            пуст другими словами когда мы всю информацию смогли отправить 
            клиенту, мы можем попытаться получать информацию для чтения ответ
            клиента, конец ответа пользователя должен стать перевод строки '\n'.
            Таким образом мы будем ставить по очередно сокет сперва на готовность
            к записи потом на готовность к чтению. На стороне клиента было бы 
            неплохо запретить пользователю вооще что либо передавать серверу 
            до тех пор пока не получим от сервера перевод строки, поняв тем 
            самым что сервер перестал задавать вопрос.
            После получения ответа от клиента, мы должны перейти в следующее
            состояние dialog_state_t и запихнуть в буфер write_buff информацию
            а также сменить состояние на ready_send_info, и поставить сокет 
            на прослушку.

        Второй модуль должен представлять из себя структуру данных которая 
            позволит нам хранить данные сессий. Особо важно грамотно продумать
            удаление закрытых сессий. Возможно стоить ввести дополнительное
            состояние kill_state которое будет обрабатываться отдельно после
            обработки событий, но перед очередной выборкой событий, на этом
            этапе я смогу безболезненно удалить завершившуюся сессию, закрыв 
            все дескриптора, "и в данной ситуации нужна структура которая 
            позволит одновременно проходить по ней и при этом удалять из 
            себя элементы", да такая структура нужна была бы но я могу 
            поступить проще, в список можно добавить поле которое будет 
            остлеживать общее количество сессий, позже я выделяю масив int 
            в которые будут писаться ключевые поля из сессий, а именно номера
            файловых дескрипторов, а все остальное должно быть проставленно в -1,
            и после просто перебираем этот масив и отдаем списку на удаление 
            номера файловых дескрипторов. После начинается снова выборка событий.
            Подробности по второму модулю смотреть в файле readme_additional.

        Третий модуль возможно стоит вынести в третий модуль логику обработки
            буферов, и структуру которая будет представлять эти же буферы. 
            Хотя в таком случае скорей всего потребуются обёртки которые 
            будут делегировать вызов скорей всего с первого модуля в третий.
            В принципе на данном этапе планирования мне нравится идея вынесения
            буферов в третий модуль, ведь открывается чудесная возможность 
            играться с буфером как я того пожелаю. Например: структуру буфера
            я могу сделать разнообразной, не объязательно хранить только сам 
            масив и его размерность, я могу добавить поле которое будет отвечать
            за количество прочитанных или же записанных данных из/в буффер, во
            время системных вызовов read и write, а потом условно суммировать 
            эти значения и просто выполняя сдвиг и возвращая указатель на позицию
            с которой можно продолжить чтение или запись данных. Возможно во время
            написания программы я найду еще какие-то возможности.
            typedef struct
            {
                char buffer[BUFFER_SIZE];
                int length;

                int offset;
            } buffer_t;

        Четвертый модуль, будет представлять из себя структуру типа:
            typedef struct
            {
                dialog_state_t state;/*key*/
                char* write_msg;
                dialog_t* next;
            } dialog_t;
            В четвертый модуль планирую вынести функцию которая соберет нам 
            список, в правильном порядке: условно сперва приветствование, вопрос1,
            вопрос2, прощание, и возможно понадобится еще одна пустая для 
            состояния kill_state. Также я предполагаю сюда же винести 
            вспомогательную функцую которая будет копировать write_msg в 
            write_buff, а возможно вынесу в третий модуль. Пока что точно 
            не знаю.


        Главная программа сервер. В основном она должна просто поднимать
            сокет на прослушивания входящих запросов на соединение, обрабатывать
            диалог между клиентом и сервером. При этом все общение должно 
            происходить в не блокирующим режиме, то есть данные будут 
            обрабатываться порционно. И для этого должен быть задействован
            системный вызов select. На стороне сервера все просто, подняли
            привязали его к файлику, поставили прослушивать. Сформировали
            fd_set-ы(сделали выборку событий), обработали события, удалили
            лишнии сессии, которые уже подошли к концу. Это общий принцып 
            работы сервера. 
            Ну а теперь от общего к частному: нужно понять на каком этапе,
            и каким образом производить скажем так обновление текущего состояния
            сессии каждого клиента. С логической точки зрения это однозначно 
            должна быть обработка событий, но нужно конкретизыровать, 
            прикинуть как лучше этот процесс организовать и впишется ли он
            в этот скажем так слой. Итак принцип работы прост, сперва нужно 
            обработать уникальную ситуацию а именно проверить нет ли в fd_set-е
            номера дескриптора сокета сервера который слушает нет ли запроса
            на подключение, если информация на слушащий дескриптор поступила
            необходимо обработать, эту уникальную ситуацию и попытаться 
            подключить нового клиента, попутно при этом сформировав для нового
            клиента сессию, и подготовив ему пачку данных для отправки к 
            клиенту, дальше используя функции из второго модуля, который содержит 
            код списка, проходимся по списку и вытаскиваем поля sd(номер 
            дескриптора сокета), проверяем в каком именно fd_set-е содержится 
            наш текущий дескриптор, если он отсутствует в обоих fd_set-ах, 
            игнорируем его, в противном случае, отдаем его в специальный 
            обработчики либо для чтения либо для записи в зависимости от текущего 
            состояния. Где произойдет чтение либо запись, по хорошему следующим
            этапом должна стать проверка состояния сессии, то есть мы выполнили
            запланированые действия и выполняем проверку, если условно действие 
            до конца не было выполненно ввиду того что наши буферы сессий не 
            пусты, то в такой ситуации мы не должны менять текущее состояние
            сессии, а также статус он тоже должен остаться не изменным это тип
            status_state_t внутри сессии. В противном случае если у нас внутреные
            буфферы пусты, нам необходимо как минимум сменить статус текущего 
            состояния, а как максимум и само состояние. Порядок действий должен
            быть следующим: по умолчанию после инициализации статус состояния 
            установлен в ready_send_info, из этого статуса мы можем перейти 
            в следующий статус ready_receive_info, а дальше попадая в 
            обработчик состояния, мы возможно будем производить манипуляции с 
            буферами если они потребуются, хотя я в этом как-то сомневаюсь, 
            возможно разве что очищать(занулять) буфер для чтения, из статуса
            состояния ready_receive_info переход происходит в статус 
            ready_change_state, на этом этапе мы должны перейти к следующей
            функции обработчика, и она должна сменить нам текущее состояние
            сессии, а также статус состояния на ready_send_info, и поместить в 
            буфер информацию которая должна быть отправленна. На этом обработку
            события можно завершить для текущей сессии. После того как обработка
            события была завершенна для всех, сессий, идет переход к следующему
            этапу, а именно закритию лишних сессий, те у которых состояние 
            установлено в kill_state. После повторяется процесс выборки события,
            обработка события, закритие сессий.

            Обработка уникального события когда клиент стучится на слушающий сокет
            чтобы установить соединение, должно иметь свой уникальный обработчик
            ведь нам же нужно подготовить новый открытий сокет, и в основном 
            сводится к тому что мы формируем новую сессию, в качестве состояния
            ставим самое первое, а статус нужно установить в ready_send_info, ну 
            и поместить информацию в буфер. И наконец саму сессию поместить в 
            список и на этом все. Ошибок здесь не будет ведь для того чтобы 
            конкретная сессия начала обрабатываться в fd_set-е должен находится, 
            номер файлового дескриптора созданной сессии, а он не может туда
            попасть так как этой сессии не существовало на момент выборки события.

            Уточнение. Во время удаления уже завершенных сессий, задача сервера
            будет заключаться в закритии сокета для чтения и записи при помощи
            системного вызова shutdown(sd, SHUT_RDWR), а после следует
            системный вызов close, и удаление сессии.

        Принцип общения между сервером и клиентом. Общение должно происходить по
            очереди клиент стучится на сервер. И сервер первым начинаем общение
            после того как соединение установленно. В этот момент клиент ожидает
            пока сервер выговорится, после этого начинает говорить клиент, после
            нажатия клавиши Enter клиент заканчивает говорить. Сервер также 
            заканчивает свой разговор при помощи '\n'.


        Клиентское приложение. Приложение скорей всего будет просто зациклено, и
            крутиться по кругу пока клиент не словит ситуацию конца файла. В моем
            представлении для этого нам потребуется перевести сокет в 
            неблокирующий режим работы, также я считаю что было бы неплохо 
            в неблокирующий режим работы перевести и стандартный ввод/вывод.
            Также можно было бы написать небольшой вспомогательный модуль с двумя
            буферами, в первом хранится полученная информация с сервера, во втором
            то что мы получили со стороны клиента через стандартный ввод. Сперва
            клиент ожидает получение всех данных со стороны сервера, ознакой 
            прекращения вещания со стороны сервера станет перевод строки '\n', 
            как только мы нашли получили всю строку от сервера, серверная сторона
            переходит в готовность получения данных от клиента. Потом клиент 
            набирает ответ для сервера и передает его серверу. ОПИСАННО 
            ПОВЕРХНОСТНО.

        Первый модуль для клиентского приложения. Для выполнения этой задачи 
            потребуются вспомогательные модули. Для начала нужно определить чем
            конкретно занят клиент в текущий момент. Вводим перечисление:
            typedef enum
            {
                ready_receive_info,
                print_received_info,
                enter_sending_info,
                ready_send_info,
            } client_state_t;
            Клиент может перебывать только в одном состояния в конкретный момент
            времени. С запуском приложения клиент находится в состоянии 
            ready_receive_info, и сокет ставиться на прослушку для получения 
            данных от сервера. Другими словами делаем выборку события, и ожидаем.
            После начинаем обработку событий. Читаем с сокета столько сколько
            можем, если при этом обнаружили что прочитали весь запрос со стороны
            сервера, нужно произвести смену текущего состояния клиента с 
            ready_receive_info на print_received_info, и ставим на прослушку
            стандартный вывод. Когда поток готов принять данные, пихаем в него 
            полученный запрос со стороны сервера(клиенту нужно знать что хочет
            от него сервер). Если весь буфер был опустошен, нужно снова сменить
            состояние, с print_received_info на enter_sending_info, и на прослушку
            ставим стандартный ввод, до тех пор пока не наступит конец строки, а
            возможно клиент захочет прервать общение с сервером в таком случае
            нужно закрыть через shutdown сокет на чтение и запись и просто выйти
            из программы. Если в буфер попал перевод строки значит ответ для 
            сервера готов. И состояние снова переводим с enter_sending_info
            на ready_send_info, сокет на прослушку, когда готов отправляем данные.
            После опустошение внутреннего буфера, снова переход в новое состояние.
            Меняем ready_send_info на ready_receive_info. Для состояния 
            ready_receive_info имеется также уникальная ситуация, например select 
            может сказать что нам что-то пришло, но при попытке чтения вызов read 
            вернет 0 это означает что сервер прекратил с нами общаться, и закрыл 
            сокет.



























