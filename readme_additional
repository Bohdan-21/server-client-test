привет. Сейчас продолжаю работать над сервером но сейчас стадия планирования, 
то как в принципе этот сервер должен выглядеть что за чем идет какие действия 
выполняются, чтобы не вышло как вчера кучу времени положил а ничего не работает.
Еще важный момент я достаточно много до этого писал на ООП языках и по этому 
си мне в своем роде немного не привычен. К чему было это все лирическое 
отступление, а собственно к тому что сейчас я рассматриваю возможность 
использовать список который будет находится в одном модуле в двух разных
местах я прикинул что можно сделать, и вот что я задумал. Условно список 
должен будет хранить две совершенно разные структуры: session_t, dialog_t, 
причем они должны находится в разных списках, а не все в одной куче. По 
моим прикидкам мне понадобится еще одна структура, которая будет олицетворять 
уникальный список как пример:
typedef struct 
{
    node_t* pointer_in_head = NULL;
    node_t* pointer_in_current = NULL;for moving on our list
} list_t;

Также потребуются две глобальные переменные:
list_t* list_for_session = NULL;
list_t* list_for_dialog = NULL;

Помимо этого нужно ввести еще одну структуру которая будет представлять из 
себя конкретный node:
typedef struct node
{
    void* pointer_on_data;
    node_t* next;
} node_t;

Условно дальше будут иметься две отдельные функции которые позволят это 
распаралелить:
void init_session_list()
{
    list_for_session = malloc(sizeof(list_t));
}

void init_dialog_list()
{
    list_for_dialog = malloc(sizeof(list_t));
}

Возможно также прийдется ввести перечисление которое позволит определить, какой
из списков хочет использовать вызывающий код:
typedef enum
{
    session_type,
    dialog_type,
} list_type;

Функциям в этом случае прийдется кастовать к определенным типам данных, но эту
особеность можно переложить на вызивающий код. Попутный вопрос насколько будет
тяжёлой условно такая вот операция?:
dialog_t dialog = (dialog_t*)get_current(dialog_type); 

Где наша функция под капотом будет работать как пример как-то так:
void* get_current(list_type lt)
{
    if (lt == dialog_type)
        return (*list_for_dialog).pointer_in_current;
    else
        return (*list_for_session).pointer_in_current;
}

С таким подходом передо мной открывается возможность использовать список впринципе
для любого типа данных, но дилема состоит в том что я не знаю будет ли такой 
наверное хак работать, и впринципе насколько часто можно увидеть похожее?


вопрос по списку. Смогу ли я кастовать вниз. имеется функция:
void create_node(list_type_t, void*);

смогу ли я например провернуть следуюющее:
session_t new_session;
/*some initialization code*/

create_node(session_type, &new_session);